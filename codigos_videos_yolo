!pip install ultralytics opencv-python-headless
# --- IMPORTA AS BIBLIOTECAS NECESS√ÅRIAS ---

from google.colab import files                 # Para fazer upload de arquivos do computador para o Colab
from ultralytics import YOLO                   # Para usar os modelos YOLOv8 (da biblioteca 'ultralytics')
from IPython.display import Video, display     # Para exibir o v√≠deo com as detec√ß√µes direto no notebook
import os                                      # Para navegar entre pastas e arquivos
import shutil                                  # Para copiar arquivos de uma pasta para outra
import cv2                                     # Para recodificar o v√≠deo

# --- FAZ O UPLOAD DO V√çDEO QUE SER√Å PROCESSADO ---

print("Envie um arquivo de v√≠deo (formato .mp4, .avi, etc.)")
uploaded = files.upload()                      # Abre a janela para o usu√°rio enviar um ou mais arquivos

# Mostra os arquivos enviados
print("Arquivos enviados:")
for filename in uploaded.keys():
    print(f"- {filename}")

video_name = input("Digite o nome exato do v√≠deo enviado (ex: video.mp4): ")

# --- VERIFICA SE O V√çDEO FOI REALMENTE ENVIADO ---

if video_name not in uploaded:
    print("Erro: v√≠deo n√£o encontrado. Verifique o nome digitado.")
else:
    # --- CARREGA O MODELO YOLOv8 ---
    # Aqui usamos o modelo pequeno 'yolov8n.pt' para rapidez (pode trocar por outro: s, m, l, x)

    model = YOLO('yolov8n.pt')

    # --- EXECUTA A DETEC√á√ÉO NO V√çDEO ESCOLHIDO ---
    results = model.predict(
        source=video_name,     # Caminho do v√≠deo que foi enviado
        save=True,             # Salva o v√≠deo com as caixas de detec√ß√£o desenhadas
        save_txt=False,        # N√£o salva os resultados em arquivos .txt (pode ativar se quiser)
        conf=0.25              # Limite de confian√ßa (de 0 a 1); abaixo disso, ignora as detec√ß√µes
    )

    # --- PROCURA O V√çDEO DE SA√çDA SALVO PELO YOLO ---
    output_dir = 'runs/detect/predict'         # Pasta padr√£o onde o YOLO salva os resultados
    output_video = None

    # Percorre os arquivos na pasta de sa√≠da
    for file in os.listdir(output_dir):
      if file.endswith(('.mp4', '.avi', '.mov', '.mkv')):  # aceita outros formatos
        output_video = os.path.join(output_dir, file)
        break

# --- EXIBE O V√çDEO COM DETEC√á√ïES E PERMITE DOWNLOAD OPCIONAL ---

if output_video:
    # CORRE√á√ÉO: Recodifica o v√≠deo usando FFmpeg para m√°xima compatibilidade
    output_path = './output_detected.mp4'
    
    print("üîÑ Recodificando v√≠deo para compatibilidade com navegador...")
    
    # Usa FFmpeg para recodificar com configura√ß√µes espec√≠ficas para web
    import subprocess
    
    cmd = [
        'ffmpeg', '-i', output_video, '-y',  # -y para sobrescrever
        '-c:v', 'libx264',           # Codec de v√≠deo H.264
        '-c:a', 'aac',               # Codec de √°udio AAC
        '-movflags', '+faststart',   # Otimiza para streaming web
        '-pix_fmt', 'yuv420p',       # Formato de pixel compat√≠vel
        '-preset', 'fast',           # Preset de codifica√ß√£o r√°pida
        output_path
    ]
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print("‚úÖ Recodifica√ß√£o conclu√≠da com sucesso!")
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è FFmpeg falhou, tentando com OpenCV...")
        # Fallback para OpenCV se FFmpeg falhar
        cap = cv2.VideoCapture(output_video)
        fps = int(cap.get(cv2.CAP_PROP_FPS))
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        
        fourcc = cv2.VideoWriter_fourcc(*'XVID')  # Codec mais compat√≠vel
        out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
        
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            out.write(frame)
        
        cap.release()
        out.release()
        print("‚úÖ Recodifica√ß√£o com OpenCV conclu√≠da!")

    print(f"\n‚úÖ V√≠deo com detec√ß√µes salvo como: output_detected.mp4")

    # Exibe o v√≠deo (m√©todo que funcionou)
    print("üé¨ Exibindo v√≠deo...")
    
    # Verifica se o arquivo foi criado corretamente
   
    # Mostra instru√ß√£o opcional para baixar
    print("\nüîΩ Clique abaixo para baixar o v√≠deo (opcional):")
    # OBS: S√≥ vai baixar se a pessoa clicar
    from IPython.display import HTML
    download_link = HTML(f'<a href="{output_path}" download target="_blank">üì• Baixar v√≠deo detectado</a>')
    display(download_link)
else:
    print("Erro: v√≠deo de sa√≠da n√£o foi encontrado.")
